//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class EmployeesService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    employeesGet(): Observable<Employee[]> {
        let url_ = this.baseUrl + "/api/human-ressources/v1/employees/employees";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeesGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Employee[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Employee[]>;
        }));
    }

    protected processEmployeesGet(response: HttpResponseBase): Observable<Employee[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Employee.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    employeesPost(body: Employee | undefined): Observable<Employee> {
        let url_ = this.baseUrl + "/api/human-ressources/v1/employees/employees";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeesPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeesPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Employee>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Employee>;
        }));
    }

    protected processEmployeesPost(response: HttpResponseBase): Observable<Employee> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Employee.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    employeeById(id: number | undefined): Observable<Employee> {
        let url_ = this.baseUrl + "/api/human-ressources/v1/employees/employee-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Employee>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Employee>;
        }));
    }

    protected processEmployeeById(response: HttpResponseBase): Observable<Employee> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Employee.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    employeeDeleteById(id: number | undefined): Observable<Employee> {
        let url_ = this.baseUrl + "/api/human-ressources/v1/employees/employee-delete-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmployeeDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmployeeDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Employee>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Employee>;
        }));
    }

    protected processEmployeeDeleteById(response: HttpResponseBase): Observable<Employee> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Employee.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SocialContributionService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    socialContributionsEmployee(): Observable<SocialContributionEmployee[]> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/social-contributions-employee";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSocialContributionsEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSocialContributionsEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SocialContributionEmployee[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SocialContributionEmployee[]>;
        }));
    }

    protected processSocialContributionsEmployee(response: HttpResponseBase): Observable<SocialContributionEmployee[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SocialContributionEmployee.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    socialContributionsEmployer(): Observable<SocialContributionEmployer[]> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/social-contributions-employer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSocialContributionsEmployer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSocialContributionsEmployer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SocialContributionEmployer[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SocialContributionEmployer[]>;
        }));
    }

    protected processSocialContributionsEmployer(response: HttpResponseBase): Observable<SocialContributionEmployer[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SocialContributionEmployer.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    taxBrackets(): Observable<TaxBracket[]> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/tax-brackets";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTaxBrackets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTaxBrackets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TaxBracket[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TaxBracket[]>;
        }));
    }

    protected processTaxBrackets(response: HttpResponseBase): Observable<TaxBracket[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaxBracket.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    fiscalYears(): Observable<FiscalYear[]> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/fiscal-years";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFiscalYears(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFiscalYears(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FiscalYear[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FiscalYear[]>;
        }));
    }

    protected processFiscalYears(response: HttpResponseBase): Observable<FiscalYear[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FiscalYear.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    governments(): Observable<Government[]> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/governments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGovernments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGovernments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Government[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Government[]>;
        }));
    }

    protected processGovernments(response: HttpResponseBase): Observable<Government[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Government.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    socialContributionEmployeeById(id: number | undefined): Observable<SocialContributionEmployee> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/social-contribution-employee-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSocialContributionEmployeeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSocialContributionEmployeeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SocialContributionEmployee>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SocialContributionEmployee>;
        }));
    }

    protected processSocialContributionEmployeeById(response: HttpResponseBase): Observable<SocialContributionEmployee> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SocialContributionEmployee.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    socialContributionEmployerById(id: number | undefined): Observable<SocialContributionEmployer> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/social-contribution-employer-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSocialContributionEmployerById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSocialContributionEmployerById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SocialContributionEmployer>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SocialContributionEmployer>;
        }));
    }

    protected processSocialContributionEmployerById(response: HttpResponseBase): Observable<SocialContributionEmployer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SocialContributionEmployer.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    taxBracketById(id: number | undefined): Observable<TaxBracket> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/tax-bracket-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTaxBracketById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTaxBracketById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TaxBracket>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TaxBracket>;
        }));
    }

    protected processTaxBracketById(response: HttpResponseBase): Observable<TaxBracket> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = TaxBracket.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    fiscalYearById(id: number | undefined): Observable<FiscalYear> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/fiscal-year-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFiscalYearById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFiscalYearById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FiscalYear>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FiscalYear>;
        }));
    }

    protected processFiscalYearById(response: HttpResponseBase): Observable<FiscalYear> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = FiscalYear.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param year (optional) 
     * @return Success
     */
    fiscalYearByYear(year: number | undefined): Observable<FiscalYear> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/fiscal-year-by-year?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFiscalYearByYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFiscalYearByYear(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FiscalYear>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FiscalYear>;
        }));
    }

    protected processFiscalYearByYear(response: HttpResponseBase): Observable<FiscalYear> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = FiscalYear.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    governmentById(id: number | undefined): Observable<Government> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/government-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGovernmentById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGovernmentById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Government>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Government>;
        }));
    }

    protected processGovernmentById(response: HttpResponseBase): Observable<Government> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Government.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    governmentByCode(code: string | undefined): Observable<Government> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/government-by-code?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGovernmentByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGovernmentByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Government>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Government>;
        }));
    }

    protected processGovernmentByCode(response: HttpResponseBase): Observable<Government> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Government.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    socialContributionEmployeeDeleteById(id: number | undefined): Observable<SocialContributionEmployee> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/social-contribution-employee-delete-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSocialContributionEmployeeDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSocialContributionEmployeeDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SocialContributionEmployee>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SocialContributionEmployee>;
        }));
    }

    protected processSocialContributionEmployeeDeleteById(response: HttpResponseBase): Observable<SocialContributionEmployee> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SocialContributionEmployee.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    socialContributionEmployerDeleteById(id: number | undefined): Observable<SocialContributionEmployer> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/social-contribution-employer-delete-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSocialContributionEmployerDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSocialContributionEmployerDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SocialContributionEmployer>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SocialContributionEmployer>;
        }));
    }

    protected processSocialContributionEmployerDeleteById(response: HttpResponseBase): Observable<SocialContributionEmployer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SocialContributionEmployer.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    taxBracketDeleteById(id: number | undefined): Observable<TaxBracket> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/tax-bracket-delete-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTaxBracketDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTaxBracketDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TaxBracket>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TaxBracket>;
        }));
    }

    protected processTaxBracketDeleteById(response: HttpResponseBase): Observable<TaxBracket> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = TaxBracket.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    fiscalYearDeleteById(id: number | undefined): Observable<FiscalYear> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/fiscal-year-delete-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFiscalYearDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFiscalYearDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FiscalYear>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FiscalYear>;
        }));
    }

    protected processFiscalYearDeleteById(response: HttpResponseBase): Observable<FiscalYear> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = FiscalYear.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    governmentDeleteById(id: number | undefined): Observable<Government> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/government-delete-by-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGovernmentDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGovernmentDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Government>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Government>;
        }));
    }

    protected processGovernmentDeleteById(response: HttpResponseBase): Observable<Government> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Government.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    socialContribubtionEmployeeCalculateTax(body: TaxCalculationsParameters | undefined): Observable<WithheldSalary> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/social-contribubtion-employee-calculate-tax";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSocialContribubtionEmployeeCalculateTax(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSocialContribubtionEmployeeCalculateTax(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WithheldSalary>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WithheldSalary>;
        }));
    }

    protected processSocialContribubtionEmployeeCalculateTax(response: HttpResponseBase): Observable<WithheldSalary> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = WithheldSalary.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    socialContributionEmployerCalculateTax(body: TaxCalculationsParameters | undefined): Observable<EmployerTaxes> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/social-contribution-employer-calculate-tax";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSocialContributionEmployerCalculateTax(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSocialContributionEmployerCalculateTax(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployerTaxes>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployerTaxes>;
        }));
    }

    protected processSocialContributionEmployerCalculateTax(response: HttpResponseBase): Observable<EmployerTaxes> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = EmployerTaxes.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    socialContributionEmployee(body: SocialContributionEmployee | undefined): Observable<SocialContributionEmployee> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/social-contribution-employee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSocialContributionEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSocialContributionEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SocialContributionEmployee>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SocialContributionEmployee>;
        }));
    }

    protected processSocialContributionEmployee(response: HttpResponseBase): Observable<SocialContributionEmployee> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SocialContributionEmployee.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    socialContributionEmployer(body: SocialContributionEmployer | undefined): Observable<SocialContributionEmployer> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/social-contribution-employer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSocialContributionEmployer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSocialContributionEmployer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SocialContributionEmployer>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SocialContributionEmployer>;
        }));
    }

    protected processSocialContributionEmployer(response: HttpResponseBase): Observable<SocialContributionEmployer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = SocialContributionEmployer.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    taxBracket(body: TaxBracket | undefined): Observable<TaxBracket> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/tax-bracket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTaxBracket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTaxBracket(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TaxBracket>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TaxBracket>;
        }));
    }

    protected processTaxBracket(response: HttpResponseBase): Observable<TaxBracket> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = TaxBracket.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    fiscalYear(body: FiscalYear | undefined): Observable<FiscalYear> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/fiscal-year";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFiscalYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFiscalYear(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FiscalYear>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FiscalYear>;
        }));
    }

    protected processFiscalYear(response: HttpResponseBase): Observable<FiscalYear> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = FiscalYear.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    government(body: Government | undefined): Observable<Government> {
        let url_ = this.baseUrl + "/api/tax/v1/social-contribution/government";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGovernment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGovernment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Government>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Government>;
        }));
    }

    protected processGovernment(response: HttpResponseBase): Observable<Government> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Government.fromJS(resultData200, _mappings);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class Employee implements IEmployee {
    id?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    birthDate?: Date;
    nas?: string | undefined;

    constructor(data?: IEmployee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.nas = _data["nas"];
        }
    }

    static fromJS(data: any, _mappings?: any): Employee | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Employee>(data, _mappings, Employee);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["nas"] = this.nas;
        return data;
    }
}

export interface IEmployee {
    id?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    birthDate?: Date;
    nas?: string | undefined;
}

export class EmployerTaxes implements IEmployerTaxes {
    rrq?: number;
    rqap?: number;
    employmentInsurance?: number;
    cnesst?: number;
    fss?: number;
    fdrcmo?: number;

    constructor(data?: IEmployerTaxes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.rrq = _data["rrq"];
            this.rqap = _data["rqap"];
            this.employmentInsurance = _data["employmentInsurance"];
            this.cnesst = _data["cnesst"];
            this.fss = _data["fss"];
            this.fdrcmo = _data["fdrcmo"];
        }
    }

    static fromJS(data: any, _mappings?: any): EmployerTaxes | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<EmployerTaxes>(data, _mappings, EmployerTaxes);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rrq"] = this.rrq;
        data["rqap"] = this.rqap;
        data["employmentInsurance"] = this.employmentInsurance;
        data["cnesst"] = this.cnesst;
        data["fss"] = this.fss;
        data["fdrcmo"] = this.fdrcmo;
        return data;
    }
}

export interface IEmployerTaxes {
    rrq?: number;
    rqap?: number;
    employmentInsurance?: number;
    cnesst?: number;
    fss?: number;
    fdrcmo?: number;
}

export class FiscalYear implements IFiscalYear {
    id?: number;
    year?: number;
    description?: string | undefined;

    constructor(data?: IFiscalYear) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.year = _data["year"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): FiscalYear | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FiscalYear>(data, _mappings, FiscalYear);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["year"] = this.year;
        data["description"] = this.description;
        return data;
    }
}

export interface IFiscalYear {
    id?: number;
    year?: number;
    description?: string | undefined;
}

export class Government implements IGovernment {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;

    constructor(data?: IGovernment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): Government | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Government>(data, _mappings, Government);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["description"] = this.description;
        return data;
    }
}

export interface IGovernment {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
}

export class SocialContributionEmployee implements ISocialContributionEmployee {
    id?: number;
    fiscalYearId?: number;
    rrqRate?: number;
    rrqMga?: number;
    employmentInsurance?: number;
    rqapRate?: number;
    rqapMga?: number;
    fiscalYear?: FiscalYear;

    constructor(data?: ISocialContributionEmployee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fiscalYearId = _data["fiscalYearId"];
            this.rrqRate = _data["rrqRate"];
            this.rrqMga = _data["rrqMga"];
            this.employmentInsurance = _data["employmentInsurance"];
            this.rqapRate = _data["rqapRate"];
            this.rqapMga = _data["rqapMga"];
            this.fiscalYear = _data["fiscalYear"] ? FiscalYear.fromJS(_data["fiscalYear"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): SocialContributionEmployee | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SocialContributionEmployee>(data, _mappings, SocialContributionEmployee);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fiscalYearId"] = this.fiscalYearId;
        data["rrqRate"] = this.rrqRate;
        data["rrqMga"] = this.rrqMga;
        data["employmentInsurance"] = this.employmentInsurance;
        data["rqapRate"] = this.rqapRate;
        data["rqapMga"] = this.rqapMga;
        data["fiscalYear"] = this.fiscalYear ? this.fiscalYear.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISocialContributionEmployee {
    id?: number;
    fiscalYearId?: number;
    rrqRate?: number;
    rrqMga?: number;
    employmentInsurance?: number;
    rqapRate?: number;
    rqapMga?: number;
    fiscalYear?: FiscalYear;
}

export class SocialContributionEmployer implements ISocialContributionEmployer {
    id?: number;
    fiscalYearId?: number;
    rrqRate?: number;
    rrqMga?: number;
    employmentInsurance?: number;
    rqapRate?: number;
    rqapMga?: number;
    cnesst?: number;
    fss?: number;
    fdrcmo?: number;
    fiscalYear?: FiscalYear;

    constructor(data?: ISocialContributionEmployer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fiscalYearId = _data["fiscalYearId"];
            this.rrqRate = _data["rrqRate"];
            this.rrqMga = _data["rrqMga"];
            this.employmentInsurance = _data["employmentInsurance"];
            this.rqapRate = _data["rqapRate"];
            this.rqapMga = _data["rqapMga"];
            this.cnesst = _data["cnesst"];
            this.fss = _data["fss"];
            this.fdrcmo = _data["fdrcmo"];
            this.fiscalYear = _data["fiscalYear"] ? FiscalYear.fromJS(_data["fiscalYear"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): SocialContributionEmployer | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SocialContributionEmployer>(data, _mappings, SocialContributionEmployer);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fiscalYearId"] = this.fiscalYearId;
        data["rrqRate"] = this.rrqRate;
        data["rrqMga"] = this.rrqMga;
        data["employmentInsurance"] = this.employmentInsurance;
        data["rqapRate"] = this.rqapRate;
        data["rqapMga"] = this.rqapMga;
        data["cnesst"] = this.cnesst;
        data["fss"] = this.fss;
        data["fdrcmo"] = this.fdrcmo;
        data["fiscalYear"] = this.fiscalYear ? this.fiscalYear.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISocialContributionEmployer {
    id?: number;
    fiscalYearId?: number;
    rrqRate?: number;
    rrqMga?: number;
    employmentInsurance?: number;
    rqapRate?: number;
    rqapMga?: number;
    cnesst?: number;
    fss?: number;
    fdrcmo?: number;
    fiscalYear?: FiscalYear;
}

export class TaxBracket implements ITaxBracket {
    id?: number;
    fiscalYearId?: number;
    governmentId?: number;
    lowerLimit?: number;
    upperLimit?: number;
    rate?: number;
    fiscalYear?: FiscalYear;
    government?: Government;

    constructor(data?: ITaxBracket) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fiscalYearId = _data["fiscalYearId"];
            this.governmentId = _data["governmentId"];
            this.lowerLimit = _data["lowerLimit"];
            this.upperLimit = _data["upperLimit"];
            this.rate = _data["rate"];
            this.fiscalYear = _data["fiscalYear"] ? FiscalYear.fromJS(_data["fiscalYear"], _mappings) : <any>undefined;
            this.government = _data["government"] ? Government.fromJS(_data["government"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): TaxBracket | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TaxBracket>(data, _mappings, TaxBracket);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fiscalYearId"] = this.fiscalYearId;
        data["governmentId"] = this.governmentId;
        data["lowerLimit"] = this.lowerLimit;
        data["upperLimit"] = this.upperLimit;
        data["rate"] = this.rate;
        data["fiscalYear"] = this.fiscalYear ? this.fiscalYear.toJSON() : <any>undefined;
        data["government"] = this.government ? this.government.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITaxBracket {
    id?: number;
    fiscalYearId?: number;
    governmentId?: number;
    lowerLimit?: number;
    upperLimit?: number;
    rate?: number;
    fiscalYear?: FiscalYear;
    government?: Government;
}

export class TaxCalculationsParameters implements ITaxCalculationsParameters {
    amount?: number;
    fiscalYearId?: number;

    constructor(data?: ITaxCalculationsParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.fiscalYearId = _data["fiscalYearId"];
        }
    }

    static fromJS(data: any, _mappings?: any): TaxCalculationsParameters | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TaxCalculationsParameters>(data, _mappings, TaxCalculationsParameters);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["fiscalYearId"] = this.fiscalYearId;
        return data;
    }
}

export interface ITaxCalculationsParameters {
    amount?: number;
    fiscalYearId?: number;
}

export class WithheldSalary implements IWithheldSalary {
    fedTax?: number;
    provTax?: number;
    rrq?: number;
    rqap?: number;
    employmentInsurance?: number;

    constructor(data?: IWithheldSalary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.fedTax = _data["fedTax"];
            this.provTax = _data["provTax"];
            this.rrq = _data["rrq"];
            this.rqap = _data["rqap"];
            this.employmentInsurance = _data["employmentInsurance"];
        }
    }

    static fromJS(data: any, _mappings?: any): WithheldSalary | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<WithheldSalary>(data, _mappings, WithheldSalary);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fedTax"] = this.fedTax;
        data["provTax"] = this.provTax;
        data["rrq"] = this.rrq;
        data["rqap"] = this.rqap;
        data["employmentInsurance"] = this.employmentInsurance;
        return data;
    }
}

export interface IWithheldSalary {
    fedTax?: number;
    provTax?: number;
    rrq?: number;
    rqap?: number;
    employmentInsurance?: number;
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T | null {
  if (!mappings)
    mappings = [];
  if (!data)
    return null;

  const mappingIndexName = "__mappingIndex";
  if (data[mappingIndexName])
    return <T>mappings[data[mappingIndexName]].target;

  data[mappingIndexName] = mappings.length;

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}